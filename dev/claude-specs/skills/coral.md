# /coral Skill

## Summary

Generate Coral diagrams from natural language descriptions directly in conversation. This is the primary user-facing skill for creating diagrams—users describe what they want, and the skill produces valid Coral DSL.

## Invocation

```
/coral <description>
```

Or interactively:
```
/coral
> Describe your diagram...
```

## Value Proposition

- **Instant diagrams**: No need to learn syntax first
- **Conversational**: Refine through follow-up messages
- **Copy-paste ready**: Output is valid Coral DSL
- **Validates Coral's AI-native design**: Proves the format works well with LLMs

## Use Cases

### UC1: Quick Sketch
```
User: /coral a simple web app with API and database

Output:
service "Web App"
service "API"
database "Database"

web_app -> api [http_request]
api -> database [data_flow]
```

### UC2: Detailed Architecture
```
User: /coral an e-commerce system with:
      - React frontend
      - Node.js API gateway
      - Microservices for auth, products, orders, payments
      - PostgreSQL for products and orders
      - Redis for session cache
      - Stripe integration for payments

Output:
service "React Frontend"
service "API Gateway"
service "Auth Service"
service "Product Service"
service "Order Service"
service "Payment Service"
database "PostgreSQL"
database "Redis Cache"
external_api "Stripe"

react_frontend -> api_gateway [http_request]
api_gateway -> auth_service [http_request]
api_gateway -> product_service [http_request]
api_gateway -> order_service [http_request]
api_gateway -> payment_service [http_request]
product_service -> postgresql [data_flow]
order_service -> postgresql [data_flow]
auth_service -> redis_cache [data_flow]
payment_service -> stripe [http_request]
```

### UC3: With Hierarchy
```
User: /coral a payment service with internal modules for validation,
      fraud detection, and stripe integration

Output:
service "Payment Service" {
  module "Validation"
  module "Fraud Detection"
  module "Stripe Integration"
}

validation -> fraud_detection
fraud_detection -> stripe_integration
```

### UC4: Iterative Refinement
```
User: /coral basic 3-tier architecture

Output:
service "Presentation"
service "Business Logic"
database "Data Store"

presentation -> business_logic
business_logic -> data_store [data_flow]

User: add a cache between business logic and data store

Output:
service "Presentation"
service "Business Logic"
database "Cache"
database "Data Store"

presentation -> business_logic
business_logic -> cache [data_flow]
cache -> data_store [data_flow]
```

## Interface

### Input Parsing

The skill should parse the input to extract:
- **Entities**: Named things that become nodes
- **Types**: Hints about what kind of node (service, database, external)
- **Relationships**: How entities connect
- **Hierarchy**: What contains what

### Type Inference

| Keywords | Inferred Type |
|----------|---------------|
| service, microservice, api, server, backend, frontend | `service` |
| database, db, postgres, mysql, mongo, store | `database` |
| cache, redis, memcached | `database` (with cache semantics) |
| external, third-party, stripe, aws, api (external) | `external_api` |
| user, client, customer, admin | `actor` |
| module, component, handler, controller | `module` |
| group, cluster, system, tier | `group` |

### Relationship Inference

| Phrases | Inferred Relation |
|---------|-------------------|
| connects to, calls, requests, sends to | `http_request` |
| stores in, reads from, writes to, queries | `data_flow` |
| depends on, uses, requires | `dependency` |
| publishes, emits, triggers | `event` |

## Output Format

### Primary Output: Coral DSL
```coral
// Generated by /coral
// Description: <original description>

service "Node Name" {
  description: "Inferred from context"
}

node_a -> node_b [relation_type]
```

### Secondary Output: Explanation
Brief summary of what was generated:
- Number of nodes by type
- Key relationships
- Assumptions made

### Optional: Graph-IR JSON
If user requests or for debugging:
```json
{
  "version": "1.0",
  "nodes": [...],
  "edges": [...]
}
```

## Behavior

### Step 1: Parse Description
- Tokenize input
- Identify entity names and types
- Extract relationship phrases
- Detect hierarchy indicators

### Step 2: Build Mental Model
- Create list of nodes with types
- Create list of edges with relations
- Organize hierarchy (parent-child)

### Step 3: Generate IDs
- Convert labels to snake_case
- Ensure uniqueness
- Handle special characters

### Step 4: Generate DSL
- Format nodes (with bodies if they have children or metadata)
- Format edges (with relation types if not default)
- Add comments for clarity

### Step 5: Validate
- Check syntax is valid
- Verify no duplicate IDs
- Confirm edges reference existing nodes

### Step 6: Explain
- Summarize what was created
- Note any assumptions
- Suggest refinements

## Error Handling

### Ambiguous Input
```
User: /coral app

Output:
I need more detail to create a useful diagram. Could you describe:
- What components does "app" have?
- What does it connect to?
- Is it a web app, mobile app, or something else?

Here's a minimal starting point:
service "App"
```

### Conflicting Information
```
User: /coral a serverless function that's also a long-running service

Output:
[generates diagram]

Note: "Serverless function" and "long-running service" are typically
different patterns. I've represented this as a service. If you meant
a Lambda/Cloud Function, consider splitting into separate nodes.
```

### Too Complex
```
User: /coral [500 words of requirements]

Output:
This is a complex system! I've generated a high-level diagram with the
main components. For a system this size, consider:
- Breaking into multiple diagrams (one per bounded context)
- Using /coral multiple times for different views

[generates top-level diagram]
```

## Examples

### Example: Standard Web Architecture

**Input:**
```
/coral standard 3-tier web architecture with load balancer
```

**Output:**
```coral
// Standard 3-tier web architecture

actor "Users"

group "Presentation Tier" {
  service "Load Balancer"
  service "Web Server"
}

group "Application Tier" {
  service "Application Server"
}

group "Data Tier" {
  database "Database"
}

users -> load_balancer [http_request]
load_balancer -> web_server [http_request]
web_server -> application_server [http_request]
application_server -> database [data_flow]
```

**Explanation:**
Created a 3-tier architecture with 6 nodes:
- 1 actor (Users)
- 4 services (Load Balancer, Web Server, Application Server)
- 1 database
- Organized into 3 groups representing traditional tiers

### Example: Event-Driven System

**Input:**
```
/coral event-driven order processing: orders come in, get validated,
then either processed or rejected, all through a message queue
```

**Output:**
```coral
// Event-driven order processing

service "Order API"
service "Message Queue"
service "Validator"
service "Processor"
service "Rejection Handler"
database "Orders DB"

order_api -> message_queue [event, label = "OrderReceived"]
message_queue -> validator [event, label = "consume"]
validator -> message_queue [event, label = "OrderValidated"]
validator -> message_queue [event, label = "OrderRejected"]
message_queue -> processor [event, label = "consume validated"]
message_queue -> rejection_handler [event, label = "consume rejected"]
processor -> orders_db [data_flow]
rejection_handler -> orders_db [data_flow]
```

## Implementation Notes

### Context Awareness
The skill should remember previous outputs in the conversation for refinement:
```
User: /coral simple api
[output]
User: add authentication
[skill remembers previous diagram, adds auth service]
```

### Defaults
When information is missing, use sensible defaults:
- Default node type: `service`
- Default relation: `dependency`
- Default direction: left-to-right flow

### Formatting
- Use consistent indentation (2 spaces)
- Group related nodes
- Order edges by source node
- Add blank lines between sections

## Dependencies

- `@coral/ir` — For validation
- `@coral/language` — For DSL syntax reference
- Conversation context — For refinement

## Open Questions

1. **Should it support diagram types?**
   - `/coral flowchart: process steps`
   - `/coral sequence: api call flow`

2. **How much explanation is helpful?**
   - Too little: user doesn't understand output
   - Too much: clutters the conversation

3. **Should it offer alternatives?**
   - "Here's a microservices version and a monolith version"

4. **Integration with visual preview?**
   - Show rendered diagram inline (in supported environments)

## Related Specifications

- [diagram-generation agent](../agents/diagram-generation.md) — Full agent version
- [/coral-validate skill](coral-validate.md) — Validate generated output
- [/coral-explain skill](coral-explain.md) — Explain existing diagrams
