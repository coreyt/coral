# Coral Architecture

This document provides a comprehensive technical specification of Coral's architecture, including problem analysis, solution design, component specifications, and integration mechanisms.

## Table of Contents

1. [Problem Description](#1-problem-description)
2. [Solution Overview](#2-solution-overview)
3. [System Architecture](#3-system-architecture)
4. [Components](#4-components)
5. [Integration Mechanisms](#5-integration-mechanisms)
6. [Data Flow](#6-data-flow)
7. [Key Algorithms](#7-key-algorithms)
8. [Performance Considerations](#8-performance-considerations)
9. [Future Considerations](#9-future-considerations)

---

## 1. Problem Description

### 1.1 The Diagramming Dilemma

Software teams face a fundamental tension when creating architecture diagrams:

#### Text-Based Tools (Mermaid, Graphviz, PlantUML)

**Strengths:**
- Version-controllable (text diffs in Git)
- Fast to type for developers
- Reproducible builds
- Can be generated programmatically

**Weaknesses:**
- **Layout Roulette**: Adding one node can completely rearrange the entire diagram
- **No Pixel Control**: Cannot specify "put this box 50px to the left"
- **Styling Friction**: Creating polished diagrams requires verbose CSS or secondary syntax
- **Mental Parser Fatigue**: Cannot "see" the diagram from the code

#### GUI-Based Tools (Lucidchart, draw.io, Miro)

**Strengths:**
- Pixel-perfect positioning
- High visual polish
- WYSIWYG editing
- Intuitive for non-developers

**Weaknesses:**
- **Binary Blobs**: Stored as opaque files (cannot diff in Git)
- **Documentation Drift**: Diagrams become stale the moment code changes
- **Manual Labor**: Every box must be placed by hand
- **No Automation**: Cannot generate from code analysis

### 1.2 The "Layout Roulette" Problem

This is the #1 complaint about text-based diagramming tools.

**Example scenario:**
```
Initial diagram (10 nodes): Clean, readable layout
Add 1 new node: Entire graph rearranges
Result: User spends 30 minutes adding "invisible edges" to force layout
```

**Root cause:** Tools like Mermaid use the Dagre layout engine, which:
- Has been unmaintained since 2018
- Uses the Sugiyama algorithm as a "black box"
- Provides no mechanism for layout hints or constraints
- Cannot specify where edges should attach to nodes (no "ports")

### 1.3 The Documentation Drift Problem

Architecture diagrams are documentation. Documentation drifts from reality.

**The cycle:**
1. Architect creates diagram manually
2. Code evolves
3. Diagram becomes outdated
4. Nobody trusts the diagram
5. Diagram is abandoned

**What's needed:** A diagram format that can be:
- Written by humans (for initial design)
- Generated by tools (for ongoing sync)
- Edited visually (for refinement)
- Diffed in version control (for review)

### 1.4 The AI Brittleness Problem

LLMs are increasingly used to generate diagrams, but they struggle with text-based formats.

**Why LLMs fail at Mermaid:**
1. **Spatial Hallucination**: LLMs predict tokens, not pixels. They cannot "see" that adding Node Z will cause 5 edge crossings.
2. **Syntax Fragility**: One missing bracket breaks the entire render.
3. **Layout Ignorance**: The LLM writes `A --> B` without knowing where A and B will appear spatially.

**What's needed:** An intermediate representation that:
- Is structurally robust (hard to generate invalid syntax)
- Separates semantics from layout (AI handles meaning, engine handles positioning)
- Uses JSON (what LLMs generate most reliably)

### 1.5 The Projectional Editing Problem

Some advanced tools attempt "dual-view" editing where text and visual stay synchronized. This is known as **projectional editing**.

**The challenges:**
1. **Round-Trip Losslessness**: Text → IR → Text should preserve formatting
2. **Hidden State**: Visual editors tend to add state (colors, positions) that text cannot express
3. **Format Preservation**: Code generation often destroys user's whitespace and comments
4. **Merge Conflicts**: Concurrent edits in different views can conflict

---

## 2. Solution Overview

### 2.1 The Symbiotic Architecture

Coral solves these problems through a **Symbiotic Loop** architecture where text and visual interfaces are equal citizens operating on a shared data model.

```
┌─────────────────────────────────────────────────────────────┐
│                    CORAL SYMBIOTIC LOOP                     │
│                                                             │
│  ┌───────────────┐                    ┌───────────────┐     │
│  │  Coral DSL    │                    │  Coral Viz    │     │
│  │  (Text)       │                    │  (Visual)     │     │
│  └───────┬───────┘                    └───────┬───────┘     │
│          │                                    │             │
│          ▼                                    ▼             │
│  ┌───────────────┐                    ┌───────────────┐     │
│  │    Parser     │                    │    Editor     │     │
│  │ (Tree-sitter) │                    │ (React Flow)  │     │
│  └───────┬───────┘                    └───────┬───────┘     │
│          │                                    │             │
│          ▼                                    ▼             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                                                     │   │
│  │              GRAPH-IR (Source of Truth)             │   │
│  │                                                     │   │
│  │   • Nodes (id, type, label, children, metadata)     │   │
│  │   • Edges (source, target, relation, label)         │   │
│  │   • Validated DAG structure                         │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│          │                                    │             │
│          ▼                                    ▼             │
│  ┌───────────────┐                    ┌───────────────┐     │
│  │    Printer    │                    │    Layout     │     │
│  │               │                    │    (ELK)      │     │
│  └───────┬───────┘                    └───────┬───────┘     │
│          │                                    │             │
│          ▼                                    ▼             │
│  ┌───────────────┐                    ┌───────────────┐     │
│  │  Coral DSL    │                    │  Coral Viz    │     │
│  │  (Updated)    │                    │  (Rendered)   │     │
│  └───────────────┘                    └───────────────┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **Source of Truth** | Graph-IR (JSON DAG) | Machine-readable, validates semantics, no layout coupling |
| **Parser** | Tree-sitter | Incremental, fault-tolerant, IDE-grade, WASM-compatible |
| **Layout Engine** | ELK (elkjs) | Constraint-based, port support, handles complex hierarchies |
| **Renderer** | React Flow | Interactive editor primitives (zoom, pan, drag, select) |
| **State Management** | Zustand | Lightweight, subscribable, integrates well with React |
| **Validation** | Zod | Runtime type validation, TypeScript inference |
| **Monorepo** | pnpm workspaces | Efficient disk usage, strict dependency isolation |

### 2.3 The Four Pillars

1. **Graph-IR** (`@coral/ir`): The canonical representation of diagram semantics
2. **Coral DSL** (`@coral/language`): Human-optimized text syntax
3. **The Bridge** (`@coral/language`): Bidirectional transformation (parse + print)
4. **Coral Viz** (`@coral/viz`): Interactive visual editor

### 2.4 Core Invariants

These properties must always hold:

1. **IR Completeness**: Any valid diagram can be represented in the Graph-IR
2. **DSL Isomorphism**: Every IR construct has exactly one DSL representation (and vice versa)
3. **Visual Parity**: The visual editor cannot create state that the DSL cannot express
4. **Round-Trip Stability**: `parse(print(ir)) === ir` (semantic equality)
5. **DAG Validity**: The Graph-IR is always a valid Directed Acyclic Graph

---

## 3. System Architecture

### 3.1 Package Structure

```
coral/
├── packages/
│   ├── ir/                      # @coral/ir
│   │   ├── src/
│   │   │   ├── types.ts         # TypeScript interfaces
│   │   │   ├── schema.ts        # Zod validation schemas
│   │   │   ├── validate.ts      # DAG validation logic
│   │   │   └── index.ts         # Public exports
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   ├── language/                # @coral/language
│   │   ├── grammar.js           # Tree-sitter grammar definition
│   │   ├── src/
│   │   │   ├── parser.ts        # Tree-sitter WASM wrapper
│   │   │   ├── bridge.ts        # CST → IR transformer
│   │   │   ├── printer.ts       # IR → DSL code generator
│   │   │   ├── visitor.ts       # AST visitor utilities
│   │   │   └── index.ts         # Public exports
│   │   ├── test/
│   │   │   ├── snapshots/       # Parser snapshot tests
│   │   │   └── roundtrip.test.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   └── viz/                     # @coral/viz
│       ├── src/
│       │   ├── components/
│       │   │   ├── nodes/       # Custom React Flow nodes
│       │   │   ├── edges/       # Custom React Flow edges
│       │   │   └── Editor.tsx   # Main editor component
│       │   ├── layout/
│       │   │   ├── elk.ts       # ELK integration
│       │   │   ├── worker.ts    # Web Worker for layout
│       │   │   └── convert.ts   # IR ↔ ELK format conversion
│       │   ├── store/
│       │   │   └── editor.ts    # Zustand store
│       │   └── index.ts         # Public exports
│       ├── package.json
│       └── tsconfig.json
│
├── apps/
│   └── playground/              # Web application
│       ├── src/
│       │   ├── App.tsx          # Main app component
│       │   ├── hooks/           # Application hooks
│       │   └── pages/           # Route pages
│       ├── package.json
│       └── vite.config.ts
│
├── pnpm-workspace.yaml
├── package.json
└── tsconfig.base.json
```

### 3.2 Dependency Graph

```
                    ┌─────────────┐
                    │  @coral/ir  │  (no dependencies)
                    └──────┬──────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
              ▼            │            ▼
    ┌─────────────────┐    │    ┌─────────────────┐
    │ @coral/language │    │    │   @coral/viz    │
    │                 │    │    │                 │
    │ • tree-sitter   │    │    │ • react-flow    │
    │ • (no viz dep)  │    │    │ • elkjs         │
    └────────┬────────┘    │    │ • zustand       │
             │             │    │ • (no lang dep) │
             │             │    └────────┬────────┘
             │             │             │
             └─────────────┼─────────────┘
                           │
                           ▼
                ┌─────────────────────┐
                │   apps/playground   │
                │                     │
                │ • @coral/language   │
                │ • @coral/viz        │
                │ • vite / next       │
                └─────────────────────┘
```

**Key constraint:** `@coral/language` and `@coral/viz` do NOT depend on each other. They only share `@coral/ir` types. The application layer (`playground`) is responsible for wiring them together.

### 3.3 Build Order

Due to the dependency graph, packages must build in this order:

```bash
1. pnpm --filter "@coral/ir" build
2. pnpm --filter "@coral/language" build    # parallel with viz
   pnpm --filter "@coral/viz" build         # parallel with language
3. pnpm --filter "playground" build
```

---

## 4. Components

### 4.1 Graph-IR (`@coral/ir`)

The Graph-IR is the canonical representation of diagram semantics. It is:
- **Layout-agnostic**: No x/y coordinates (those are computed by ELK)
- **Style-agnostic**: No colors/fonts (those are applied by the renderer)
- **Strictly typed**: Validated by Zod schemas at runtime boundaries

#### 4.1.1 Type Definitions

```typescript
// packages/ir/src/types.ts

/**
 * Node types supported by Coral.
 * Extensible for domain-specific diagram types.
 */
export type NodeType =
  | 'service'
  | 'module'
  | 'database'
  | 'external_api'
  | 'actor'
  | 'group';

/**
 * A node in the graph. May contain children for hierarchical diagrams.
 */
export interface CoralNode {
  /** Unique identifier within the graph */
  id: string;

  /** Semantic type (affects rendering) */
  type: NodeType;

  /** Human-readable label */
  label: string;

  /** Nested child nodes (for drill-down) */
  children?: CoralNode[];

  /** Arbitrary metadata (repo links, descriptions, etc.) */
  metadata?: Record<string, unknown>;

  /** Port definitions for constrained edge attachment */
  ports?: CoralPort[];
}

/**
 * A port is a specific attachment point on a node.
 * Enables precise control over where edges connect.
 */
export interface CoralPort {
  /** Unique identifier within the node */
  id: string;

  /** Which side of the node this port is on */
  side: 'north' | 'south' | 'east' | 'west';

  /** Optional label for the port */
  label?: string;
}

/**
 * Relationship types for edges.
 * Affects rendering style (arrow type, line style).
 */
export type RelationType =
  | 'dependency'
  | 'data_flow'
  | 'http_request'
  | 'event'
  | 'inherits'
  | 'contains';

/**
 * An edge connecting two nodes.
 */
export interface CoralEdge {
  /** Source node ID */
  source: string;

  /** Target node ID */
  target: string;

  /** Semantic relationship type */
  relation: RelationType;

  /** Optional label on the edge */
  label?: string;

  /** Source port ID (if using port constraints) */
  sourcePort?: string;

  /** Target port ID (if using port constraints) */
  targetPort?: string;

  /** Arbitrary metadata */
  metadata?: Record<string, unknown>;
}

/**
 * The complete graph structure.
 */
export interface CoralGraph {
  /** Graph format version */
  version: '1.0';

  /** All nodes in the graph */
  nodes: CoralNode[];

  /** All edges in the graph */
  edges: CoralEdge[];

  /** Graph-level metadata */
  metadata?: {
    title?: string;
    description?: string;
    [key: string]: unknown;
  };
}
```

#### 4.1.2 Validation Schema

```typescript
// packages/ir/src/schema.ts
import { z } from 'zod';

export const NodeTypeSchema = z.enum([
  'service',
  'module',
  'database',
  'external_api',
  'actor',
  'group',
]);

export const PortSideSchema = z.enum(['north', 'south', 'east', 'west']);

export const CoralPortSchema = z.object({
  id: z.string().min(1),
  side: PortSideSchema,
  label: z.string().optional(),
});

export const CoralNodeSchema: z.ZodType<CoralNode> = z.lazy(() =>
  z.object({
    id: z.string().min(1),
    type: NodeTypeSchema,
    label: z.string(),
    children: z.array(CoralNodeSchema).optional(),
    metadata: z.record(z.unknown()).optional(),
    ports: z.array(CoralPortSchema).optional(),
  })
);

export const RelationTypeSchema = z.enum([
  'dependency',
  'data_flow',
  'http_request',
  'event',
  'inherits',
  'contains',
]);

export const CoralEdgeSchema = z.object({
  source: z.string().min(1),
  target: z.string().min(1),
  relation: RelationTypeSchema,
  label: z.string().optional(),
  sourcePort: z.string().optional(),
  targetPort: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
});

export const CoralGraphSchema = z.object({
  version: z.literal('1.0'),
  nodes: z.array(CoralNodeSchema),
  edges: z.array(CoralEdgeSchema),
  metadata: z.object({
    title: z.string().optional(),
    description: z.string().optional(),
  }).passthrough().optional(),
});
```

#### 4.1.3 DAG Validation

```typescript
// packages/ir/src/validate.ts
import type { CoralGraph, CoralNode } from './types';

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

export interface ValidationError {
  code: string;
  message: string;
  path?: string[];
}

/**
 * Validates that the graph is a valid DAG (no cycles).
 * Uses DFS with coloring to detect back edges.
 */
export function validateDAG(graph: CoralGraph): ValidationResult {
  const errors: ValidationError[] = [];
  const nodeIds = new Set(flattenNodes(graph.nodes).map(n => n.id));

  // Check for duplicate node IDs
  const seenIds = new Set<string>();
  for (const node of flattenNodes(graph.nodes)) {
    if (seenIds.has(node.id)) {
      errors.push({
        code: 'DUPLICATE_NODE_ID',
        message: `Duplicate node ID: ${node.id}`,
        path: ['nodes', node.id],
      });
    }
    seenIds.add(node.id);
  }

  // Check for edges referencing non-existent nodes
  for (const edge of graph.edges) {
    if (!nodeIds.has(edge.source)) {
      errors.push({
        code: 'INVALID_EDGE_SOURCE',
        message: `Edge references non-existent source: ${edge.source}`,
        path: ['edges', `${edge.source}->${edge.target}`],
      });
    }
    if (!nodeIds.has(edge.target)) {
      errors.push({
        code: 'INVALID_EDGE_TARGET',
        message: `Edge references non-existent target: ${edge.target}`,
        path: ['edges', `${edge.source}->${edge.target}`],
      });
    }
  }

  // Check for cycles using DFS
  const WHITE = 0, GRAY = 1, BLACK = 2;
  const color = new Map<string, number>();
  const adjacency = buildAdjacencyList(graph);

  for (const nodeId of nodeIds) {
    color.set(nodeId, WHITE);
  }

  function dfs(nodeId: string, path: string[]): boolean {
    color.set(nodeId, GRAY);

    for (const neighbor of adjacency.get(nodeId) || []) {
      if (color.get(neighbor) === GRAY) {
        // Back edge found - cycle detected
        const cycleStart = path.indexOf(neighbor);
        const cyclePath = [...path.slice(cycleStart), neighbor];
        errors.push({
          code: 'CYCLE_DETECTED',
          message: `Cycle detected: ${cyclePath.join(' -> ')}`,
          path: ['edges'],
        });
        return true;
      }
      if (color.get(neighbor) === WHITE) {
        if (dfs(neighbor, [...path, neighbor])) {
          return true;
        }
      }
    }

    color.set(nodeId, BLACK);
    return false;
  }

  for (const nodeId of nodeIds) {
    if (color.get(nodeId) === WHITE) {
      dfs(nodeId, [nodeId]);
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

function flattenNodes(nodes: CoralNode[]): CoralNode[] {
  const result: CoralNode[] = [];
  for (const node of nodes) {
    result.push(node);
    if (node.children) {
      result.push(...flattenNodes(node.children));
    }
  }
  return result;
}

function buildAdjacencyList(graph: CoralGraph): Map<string, string[]> {
  const adjacency = new Map<string, string[]>();
  for (const edge of graph.edges) {
    if (!adjacency.has(edge.source)) {
      adjacency.set(edge.source, []);
    }
    adjacency.get(edge.source)!.push(edge.target);
  }
  return adjacency;
}
```

---

### 4.2 Coral DSL (`@coral/language`)

The DSL provides a human-optimized syntax for writing diagrams. It is designed to be:
- **Concise**: Minimize keystrokes for common patterns
- **Readable**: Clear visual structure
- **Familiar**: C-like syntax (braces, arrows)
- **Unambiguous**: LL(1) grammar, no syntactic ambiguity

#### 4.2.1 Grammar Design

```javascript
// packages/language/grammar.js
module.exports = grammar({
  name: 'coral',

  extras: $ => [
    /\s/,           // Whitespace
    $.comment,      // Comments
  ],

  rules: {
    // Entry point
    source_file: $ => repeat(choice(
      $.node_declaration,
      $.edge_declaration,
    )),

    // Comments
    comment: $ => choice(
      seq('//', /.*/),                    // Single-line
      seq('/*', /[^*]*\*+([^/*][^*]*\*+)*/, '/'),  // Multi-line
    ),

    // Node declaration: service "API Gateway" { ... }
    node_declaration: $ => seq(
      field('type', $.node_type),
      field('name', $.string),
      optional(field('body', $.node_body)),
    ),

    node_type: $ => choice(
      'service',
      'module',
      'database',
      'external_api',
      'actor',
      'group',
    ),

    node_body: $ => seq(
      '{',
      repeat(choice(
        $.property,
        $.port_declaration,
        $.node_declaration,  // Nested nodes
      )),
      '}',
    ),

    // Property: label: "Payment Service"
    property: $ => seq(
      field('key', $.identifier),
      ':',
      field('value', $.value),
    ),

    // Port declaration: port input(west)
    port_declaration: $ => seq(
      'port',
      field('name', $.identifier),
      optional(seq('(', field('side', $.port_side), ')')),
    ),

    port_side: $ => choice('north', 'south', 'east', 'west'),

    // Edge declaration: api_gateway -> payment_service [http_request]
    edge_declaration: $ => seq(
      field('source', $.node_ref),
      '->',
      field('target', $.node_ref),
      optional(field('attributes', $.edge_attributes)),
    ),

    node_ref: $ => seq(
      $.identifier,
      optional(seq('.', $.identifier)),  // Port reference: node.port
    ),

    edge_attributes: $ => seq(
      '[',
      sepBy(',', $.edge_attribute),
      ']',
    ),

    edge_attribute: $ => choice(
      field('relation', $.relation_type),
      seq(field('key', $.identifier), '=', field('value', $.value)),
    ),

    relation_type: $ => choice(
      'dependency',
      'data_flow',
      'http_request',
      'event',
      'inherits',
      'contains',
    ),

    // Primitives
    identifier: $ => /[a-zA-Z_][a-zA-Z0-9_]*/,
    string: $ => /"[^"]*"/,
    number: $ => /[0-9]+/,
    value: $ => choice($.string, $.number, $.identifier),
  },
});

function sepBy(sep, rule) {
  return optional(seq(rule, repeat(seq(sep, rule))));
}
```

#### 4.2.2 Example DSL Syntax

```coral
// E-commerce Architecture Diagram

service "API Gateway" {
  description: "Entry point for all client requests"
  port input(west)
  port output(east)
}

service "Order Service" {
  module "Order Handler" {
    description: "Processes new orders"
  }
  module "Order Validator" {
    description: "Validates order data"
  }
}

service "Payment Service" {
  port stripe_out(east)
}

database "Orders DB" {
  description: "PostgreSQL database"
}

external_api "Stripe" {
  description: "Payment processor"
}

// Edges
api_gateway.output -> order_service [http_request, label = "POST /orders"]
order_service -> orders_db [data_flow]
order_service -> payment_service [http_request]
payment_service.stripe_out -> stripe [http_request, label = "Charge card"]
```

#### 4.2.3 Parser Implementation

```typescript
// packages/language/src/parser.ts
import Parser from 'web-tree-sitter';

let initialized = false;
let parser: Parser | null = null;
let coralLanguage: Parser.Language | null = null;

export async function initializeParser(): Promise<void> {
  if (initialized) return;

  await Parser.init({
    locateFile: (scriptName: string) => {
      // In browser: serve from public directory
      // In Node: resolve from node_modules
      return `/tree-sitter.wasm`;
    },
  });

  parser = new Parser();
  coralLanguage = await Parser.Language.load('/tree-sitter-coral.wasm');
  parser.setLanguage(coralLanguage);

  initialized = true;
}

export async function parse(source: string): Promise<Parser.Tree> {
  await initializeParser();
  if (!parser) throw new Error('Parser not initialized');
  return parser.parse(source);
}

export async function parseIncremental(
  source: string,
  previousTree: Parser.Tree,
  edit: Parser.Edit
): Promise<Parser.Tree> {
  await initializeParser();
  if (!parser) throw new Error('Parser not initialized');

  previousTree.edit(edit);
  return parser.parse(source, previousTree);
}
```

#### 4.2.4 Bridge (CST to IR)

```typescript
// packages/language/src/bridge.ts
import type { SyntaxNode } from 'web-tree-sitter';
import type { CoralGraph, CoralNode, CoralEdge, CoralPort } from '@coral/ir';

export function cstToGraph(rootNode: SyntaxNode): CoralGraph {
  const nodes: CoralNode[] = [];
  const edges: CoralEdge[] = [];

  for (let i = 0; i < rootNode.childCount; i++) {
    const child = rootNode.child(i);
    if (!child) continue;

    if (child.type === 'node_declaration') {
      nodes.push(visitNodeDeclaration(child));
    } else if (child.type === 'edge_declaration') {
      edges.push(visitEdgeDeclaration(child));
    }
  }

  return {
    version: '1.0',
    nodes,
    edges,
  };
}

function visitNodeDeclaration(node: SyntaxNode): CoralNode {
  const typeNode = node.childForFieldName('type');
  const nameNode = node.childForFieldName('name');
  const bodyNode = node.childForFieldName('body');

  const coralNode: CoralNode = {
    id: normalizeId(nameNode?.text || ''),
    type: (typeNode?.text as CoralNode['type']) || 'service',
    label: unquote(nameNode?.text || ''),
  };

  if (bodyNode) {
    const { properties, ports, children } = visitNodeBody(bodyNode);

    if (Object.keys(properties).length > 0) {
      coralNode.metadata = properties;
    }
    if (ports.length > 0) {
      coralNode.ports = ports;
    }
    if (children.length > 0) {
      coralNode.children = children;
    }
  }

  return coralNode;
}

function visitNodeBody(node: SyntaxNode): {
  properties: Record<string, unknown>;
  ports: CoralPort[];
  children: CoralNode[];
} {
  const properties: Record<string, unknown> = {};
  const ports: CoralPort[] = [];
  const children: CoralNode[] = [];

  for (let i = 0; i < node.childCount; i++) {
    const child = node.child(i);
    if (!child) continue;

    if (child.type === 'property') {
      const key = child.childForFieldName('key')?.text;
      const value = child.childForFieldName('value')?.text;
      if (key && value) {
        properties[key] = unquote(value);
      }
    } else if (child.type === 'port_declaration') {
      ports.push(visitPortDeclaration(child));
    } else if (child.type === 'node_declaration') {
      children.push(visitNodeDeclaration(child));
    }
  }

  return { properties, ports, children };
}

function visitPortDeclaration(node: SyntaxNode): CoralPort {
  const nameNode = node.childForFieldName('name');
  const sideNode = node.childForFieldName('side');

  return {
    id: nameNode?.text || '',
    side: (sideNode?.text as CoralPort['side']) || 'east',
  };
}

function visitEdgeDeclaration(node: SyntaxNode): CoralEdge {
  const sourceNode = node.childForFieldName('source');
  const targetNode = node.childForFieldName('target');
  const attributesNode = node.childForFieldName('attributes');

  const { nodeId: source, portId: sourcePort } = parseNodeRef(sourceNode);
  const { nodeId: target, portId: targetPort } = parseNodeRef(targetNode);

  const edge: CoralEdge = {
    source,
    target,
    relation: 'dependency',
  };

  if (sourcePort) edge.sourcePort = sourcePort;
  if (targetPort) edge.targetPort = targetPort;

  if (attributesNode) {
    const attrs = visitEdgeAttributes(attributesNode);
    if (attrs.relation) edge.relation = attrs.relation;
    if (attrs.label) edge.label = attrs.label;
    if (attrs.metadata) edge.metadata = attrs.metadata;
  }

  return edge;
}

function parseNodeRef(node: SyntaxNode | null): { nodeId: string; portId?: string } {
  if (!node) return { nodeId: '' };

  const text = node.text;
  if (text.includes('.')) {
    const [nodeId, portId] = text.split('.');
    return { nodeId: normalizeId(nodeId), portId };
  }
  return { nodeId: normalizeId(text) };
}

function visitEdgeAttributes(node: SyntaxNode): {
  relation?: CoralEdge['relation'];
  label?: string;
  metadata?: Record<string, unknown>;
} {
  const result: ReturnType<typeof visitEdgeAttributes> = {};
  const metadata: Record<string, unknown> = {};

  for (let i = 0; i < node.childCount; i++) {
    const child = node.child(i);
    if (!child || child.type !== 'edge_attribute') continue;

    const relationNode = child.childForFieldName('relation');
    if (relationNode) {
      result.relation = relationNode.text as CoralEdge['relation'];
      continue;
    }

    const keyNode = child.childForFieldName('key');
    const valueNode = child.childForFieldName('value');
    if (keyNode && valueNode) {
      const key = keyNode.text;
      const value = unquote(valueNode.text);
      if (key === 'label') {
        result.label = value;
      } else {
        metadata[key] = value;
      }
    }
  }

  if (Object.keys(metadata).length > 0) {
    result.metadata = metadata;
  }

  return result;
}

// Utilities
function normalizeId(str: string): string {
  return unquote(str)
    .toLowerCase()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
}

function unquote(str: string): string {
  if (str.startsWith('"') && str.endsWith('"')) {
    return str.slice(1, -1);
  }
  return str;
}
```

#### 4.2.5 Printer (IR to DSL)

```typescript
// packages/language/src/printer.ts
import type { CoralGraph, CoralNode, CoralEdge, CoralPort } from '@coral/ir';

export interface PrinterOptions {
  indent?: string;
  includeMetadata?: boolean;
}

const DEFAULT_OPTIONS: Required<PrinterOptions> = {
  indent: '  ',
  includeMetadata: true,
};

export function graphToDSL(graph: CoralGraph, options?: PrinterOptions): string {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const lines: string[] = [];

  // Print nodes
  for (const node of graph.nodes) {
    lines.push(printNode(node, 0, opts));
    lines.push('');
  }

  // Print edges
  if (graph.edges.length > 0) {
    lines.push('// Edges');
    for (const edge of graph.edges) {
      lines.push(printEdge(edge));
    }
  }

  return lines.join('\n').trim() + '\n';
}

function printNode(node: CoralNode, depth: number, opts: Required<PrinterOptions>): string {
  const indent = opts.indent.repeat(depth);
  const lines: string[] = [];

  // Node declaration
  const hasBody =
    (opts.includeMetadata && node.metadata && Object.keys(node.metadata).length > 0) ||
    (node.ports && node.ports.length > 0) ||
    (node.children && node.children.length > 0);

  if (hasBody) {
    lines.push(`${indent}${node.type} "${node.label}" {`);

    // Properties from metadata
    if (opts.includeMetadata && node.metadata) {
      for (const [key, value] of Object.entries(node.metadata)) {
        lines.push(`${indent}${opts.indent}${key}: "${value}"`);
      }
    }

    // Ports
    if (node.ports) {
      for (const port of node.ports) {
        lines.push(`${indent}${opts.indent}${printPort(port)}`);
      }
    }

    // Children
    if (node.children) {
      for (const child of node.children) {
        lines.push(printNode(child, depth + 1, opts));
      }
    }

    lines.push(`${indent}}`);
  } else {
    lines.push(`${indent}${node.type} "${node.label}"`);
  }

  return lines.join('\n');
}

function printPort(port: CoralPort): string {
  if (port.side !== 'east') {
    return `port ${port.id}(${port.side})`;
  }
  return `port ${port.id}`;
}

function printEdge(edge: CoralEdge): string {
  const source = edge.sourcePort ? `${edge.source}.${edge.sourcePort}` : edge.source;
  const target = edge.targetPort ? `${edge.target}.${edge.targetPort}` : edge.target;

  const attributes: string[] = [];

  if (edge.relation !== 'dependency') {
    attributes.push(edge.relation);
  }

  if (edge.label) {
    attributes.push(`label = "${edge.label}"`);
  }

  if (edge.metadata) {
    for (const [key, value] of Object.entries(edge.metadata)) {
      attributes.push(`${key} = "${value}"`);
    }
  }

  if (attributes.length > 0) {
    return `${source} -> ${target} [${attributes.join(', ')}]`;
  }

  return `${source} -> ${target}`;
}
```

---

### 4.3 Coral Viz (`@coral/viz`)

The visual editor provides an interactive interface for manipulating diagrams. It is built on:
- **React Flow**: Canvas, zoom, pan, node/edge rendering
- **ELK**: Automatic layout computation
- **Zustand**: State management

#### 4.3.1 Store Design

```typescript
// packages/viz/src/store/editor.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import type { Node, Edge } from '@xyflow/react';
import type { CoralGraph, CoralNode, CoralEdge } from '@coral/ir';
import { layoutGraph } from '../layout/elk';

export interface EditorState {
  // Source of truth
  graph: CoralGraph;

  // React Flow state (derived from graph + layout)
  nodes: Node[];
  edges: Edge[];

  // UI state
  selectedNodeId: string | null;
  isLayouting: boolean;
  layoutError: string | null;

  // Actions
  setGraph: (graph: CoralGraph) => Promise<void>;
  updateNode: (nodeId: string, updates: Partial<CoralNode>) => Promise<void>;
  addNode: (node: CoralNode, position?: { x: number; y: number }) => Promise<void>;
  deleteNode: (nodeId: string) => Promise<void>;
  addEdge: (edge: CoralEdge) => Promise<void>;
  deleteEdge: (source: string, target: string) => Promise<void>;
  selectNode: (nodeId: string | null) => void;

  // Layout
  recalculateLayout: () => Promise<void>;

  // React Flow callbacks
  onNodesChange: (changes: any[]) => void;
  onEdgesChange: (changes: any[]) => void;
}

export const useEditorStore = create<EditorState>()(
  subscribeWithSelector((set, get) => ({
    // Initial state
    graph: { version: '1.0', nodes: [], edges: [] },
    nodes: [],
    edges: [],
    selectedNodeId: null,
    isLayouting: false,
    layoutError: null,

    // Set entire graph (e.g., from parsed DSL)
    setGraph: async (graph) => {
      set({ isLayouting: true, layoutError: null });

      try {
        const { nodes, edges } = await layoutGraph(graph);
        set({ graph, nodes, edges, isLayouting: false });
      } catch (error) {
        set({
          layoutError: error instanceof Error ? error.message : 'Layout failed',
          isLayouting: false
        });
      }
    },

    // Update a single node
    updateNode: async (nodeId, updates) => {
      const graph = { ...get().graph };
      const nodeIndex = graph.nodes.findIndex(n => n.id === nodeId);

      if (nodeIndex >= 0) {
        graph.nodes[nodeIndex] = { ...graph.nodes[nodeIndex], ...updates };
        await get().setGraph(graph);
      }
    },

    // Add a new node
    addNode: async (node, position) => {
      const graph = { ...get().graph };
      graph.nodes = [...graph.nodes, node];
      await get().setGraph(graph);
    },

    // Delete a node and its edges
    deleteNode: async (nodeId) => {
      const graph = {
        ...get().graph,
        nodes: get().graph.nodes.filter(n => n.id !== nodeId),
        edges: get().graph.edges.filter(
          e => e.source !== nodeId && e.target !== nodeId
        ),
      };
      await get().setGraph(graph);
    },

    // Add an edge
    addEdge: async (edge) => {
      const graph = { ...get().graph };
      graph.edges = [...graph.edges, edge];
      await get().setGraph(graph);
    },

    // Delete an edge
    deleteEdge: async (source, target) => {
      const graph = {
        ...get().graph,
        edges: get().graph.edges.filter(
          e => !(e.source === source && e.target === target)
        ),
      };
      await get().setGraph(graph);
    },

    // Select a node
    selectNode: (nodeId) => {
      set({ selectedNodeId: nodeId });
    },

    // Recalculate layout
    recalculateLayout: async () => {
      await get().setGraph(get().graph);
    },

    // React Flow change handlers
    onNodesChange: (changes) => {
      // Handle position changes, selection, etc.
      // Note: We don't update the IR position (layout-agnostic)
      // but we do update the React Flow node positions for dragging
      set(state => ({
        nodes: applyNodeChanges(changes, state.nodes),
      }));
    },

    onEdgesChange: (changes) => {
      set(state => ({
        edges: applyEdgeChanges(changes, state.edges),
      }));
    },
  }))
);

// Helper to apply React Flow changes
function applyNodeChanges(changes: any[], nodes: Node[]): Node[] {
  // Implementation using @xyflow/react's applyNodeChanges
  return nodes; // Simplified
}

function applyEdgeChanges(changes: any[], edges: Edge[]): Edge[] {
  return edges; // Simplified
}
```

#### 4.3.2 ELK Integration

```typescript
// packages/viz/src/layout/elk.ts
import ELK, { ElkNode, ElkExtendedEdge } from 'elkjs/lib/elk.bundled.js';
import type { Node, Edge } from '@xyflow/react';
import type { CoralGraph, CoralNode } from '@coral/ir';

const elk = new ELK();

const DEFAULT_LAYOUT_OPTIONS = {
  'elk.algorithm': 'layered',
  'elk.direction': 'RIGHT',
  'elk.spacing.nodeNode': '80',
  'elk.layered.spacing.edgeEdgeBetweenLayers': '30',
  'elk.layered.spacing.nodeNodeBetweenLayers': '100',
  'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
};

export async function layoutGraph(graph: CoralGraph): Promise<{
  nodes: Node[];
  edges: Edge[];
}> {
  const elkGraph = coralToElk(graph);
  const layouted = await elk.layout(elkGraph);
  return elkToReactFlow(layouted, graph);
}

function coralToElk(graph: CoralGraph): ElkNode {
  const children: ElkNode[] = graph.nodes.map(node => ({
    id: node.id,
    width: calculateNodeWidth(node),
    height: calculateNodeHeight(node),
    labels: [{ text: node.label }],
    ports: node.ports?.map(port => ({
      id: `${node.id}.${port.id}`,
      properties: {
        'port.side': port.side.toUpperCase(),
      },
    })),
    // Recursively handle children
    children: node.children ? node.children.map(child => ({
      id: child.id,
      width: calculateNodeWidth(child),
      height: calculateNodeHeight(child),
      labels: [{ text: child.label }],
    })) : undefined,
  }));

  const edges: ElkExtendedEdge[] = graph.edges.map((edge, index) => ({
    id: `e${index}`,
    sources: [edge.sourcePort ? `${edge.source}.${edge.sourcePort}` : edge.source],
    targets: [edge.targetPort ? `${edge.target}.${edge.targetPort}` : edge.target],
    labels: edge.label ? [{ text: edge.label }] : undefined,
  }));

  return {
    id: 'root',
    layoutOptions: DEFAULT_LAYOUT_OPTIONS,
    children,
    edges,
  };
}

function elkToReactFlow(
  elkGraph: ElkNode,
  originalGraph: CoralGraph
): { nodes: Node[]; edges: Edge[] } {
  const nodes: Node[] = [];
  const edges: Edge[] = [];

  function processElkNode(elkNode: ElkNode, coralNode: CoralNode): void {
    nodes.push({
      id: elkNode.id,
      type: coralNode.type,
      position: { x: elkNode.x || 0, y: elkNode.y || 0 },
      data: {
        label: coralNode.label,
        type: coralNode.type,
        metadata: coralNode.metadata,
        ports: coralNode.ports,
      },
      style: {
        width: elkNode.width,
        height: elkNode.height,
      },
    });

    // Process children
    if (elkNode.children && coralNode.children) {
      elkNode.children.forEach((elkChild, index) => {
        const coralChild = coralNode.children![index];
        if (coralChild) {
          processElkNode(elkChild, coralChild);
        }
      });
    }
  }

  elkGraph.children?.forEach((elkNode, index) => {
    const coralNode = originalGraph.nodes[index];
    if (coralNode) {
      processElkNode(elkNode, coralNode);
    }
  });

  // Convert edges
  originalGraph.edges.forEach((coralEdge, index) => {
    const elkEdge = elkGraph.edges?.[index];
    edges.push({
      id: `e${index}`,
      source: coralEdge.source,
      target: coralEdge.target,
      sourceHandle: coralEdge.sourcePort,
      targetHandle: coralEdge.targetPort,
      label: coralEdge.label,
      data: {
        relation: coralEdge.relation,
        metadata: coralEdge.metadata,
      },
    });
  });

  return { nodes, edges };
}

function calculateNodeWidth(node: CoralNode): number {
  const baseWidth = 150;
  const labelWidth = node.label.length * 8;
  return Math.max(baseWidth, labelWidth + 40);
}

function calculateNodeHeight(node: CoralNode): number {
  const baseHeight = 50;
  const portHeight = (node.ports?.length || 0) * 20;
  const childrenHeight = node.children ? node.children.length * 30 : 0;
  return Math.max(baseHeight, portHeight, childrenHeight) + 20;
}
```

#### 4.3.3 Custom Node Components

```typescript
// packages/viz/src/components/nodes/ServiceNode.tsx
import { Handle, Position, NodeProps } from '@xyflow/react';
import type { CoralNode, CoralPort } from '@coral/ir';

interface ServiceNodeData {
  label: string;
  type: CoralNode['type'];
  metadata?: Record<string, unknown>;
  ports?: CoralPort[];
}

export function ServiceNode({ data, selected }: NodeProps<ServiceNodeData>) {
  const { label, type, metadata, ports } = data;

  // Group ports by side
  const portsBySide = (ports || []).reduce((acc, port) => {
    acc[port.side] = acc[port.side] || [];
    acc[port.side].push(port);
    return acc;
  }, {} as Record<string, CoralPort[]>);

  return (
    <div className={`coral-node coral-node--${type} ${selected ? 'selected' : ''}`}>
      {/* North ports */}
      {portsBySide.north?.map((port, i) => (
        <Handle
          key={port.id}
          id={port.id}
          type="target"
          position={Position.Top}
          style={{ left: `${((i + 1) / (portsBySide.north.length + 1)) * 100}%` }}
        />
      ))}

      {/* West ports */}
      {portsBySide.west?.map((port, i) => (
        <Handle
          key={port.id}
          id={port.id}
          type="target"
          position={Position.Left}
          style={{ top: `${((i + 1) / (portsBySide.west.length + 1)) * 100}%` }}
        />
      ))}

      {/* Node content */}
      <div className="coral-node__header">
        <span className="coral-node__type">{type}</span>
      </div>
      <div className="coral-node__label">{label}</div>
      {metadata?.description && (
        <div className="coral-node__description">
          {String(metadata.description)}
        </div>
      )}

      {/* East ports */}
      {portsBySide.east?.map((port, i) => (
        <Handle
          key={port.id}
          id={port.id}
          type="source"
          position={Position.Right}
          style={{ top: `${((i + 1) / (portsBySide.east.length + 1)) * 100}%` }}
        />
      ))}

      {/* South ports */}
      {portsBySide.south?.map((port, i) => (
        <Handle
          key={port.id}
          id={port.id}
          type="source"
          position={Position.Bottom}
          style={{ left: `${((i + 1) / (portsBySide.south.length + 1)) * 100}%` }}
        />
      ))}

      {/* Default handles if no ports defined */}
      {!ports?.length && (
        <>
          <Handle type="target" position={Position.Left} />
          <Handle type="source" position={Position.Right} />
        </>
      )}
    </div>
  );
}
```

#### 4.3.4 Main Editor Component

```typescript
// packages/viz/src/components/Editor.tsx
import { useCallback, useEffect } from 'react';
import {
  ReactFlow,
  Background,
  Controls,
  MiniMap,
  useReactFlow,
  type OnConnect,
} from '@xyflow/react';
import { useEditorStore } from '../store/editor';
import { ServiceNode } from './nodes/ServiceNode';
import { DependencyEdge } from './edges/DependencyEdge';
import type { CoralGraph } from '@coral/ir';

import '@xyflow/react/dist/style.css';

const nodeTypes = {
  service: ServiceNode,
  module: ServiceNode,
  database: ServiceNode,
  external_api: ServiceNode,
  actor: ServiceNode,
  group: ServiceNode,
};

const edgeTypes = {
  dependency: DependencyEdge,
  data_flow: DependencyEdge,
  http_request: DependencyEdge,
  event: DependencyEdge,
};

export interface EditorProps {
  initialGraph?: CoralGraph;
  onChange?: (graph: CoralGraph) => void;
  readOnly?: boolean;
}

export function Editor({ initialGraph, onChange, readOnly = false }: EditorProps) {
  const {
    nodes,
    edges,
    graph,
    isLayouting,
    layoutError,
    setGraph,
    addEdge,
    onNodesChange,
    onEdgesChange,
  } = useEditorStore();

  const { fitView } = useReactFlow();

  // Initialize with provided graph
  useEffect(() => {
    if (initialGraph) {
      setGraph(initialGraph);
    }
  }, [initialGraph, setGraph]);

  // Notify parent of changes
  useEffect(() => {
    onChange?.(graph);
  }, [graph, onChange]);

  // Fit view after layout
  useEffect(() => {
    if (!isLayouting && nodes.length > 0) {
      setTimeout(() => fitView({ padding: 0.1 }), 50);
    }
  }, [isLayouting, nodes.length, fitView]);

  // Handle new connections
  const onConnect: OnConnect = useCallback(
    (connection) => {
      if (readOnly) return;
      if (connection.source && connection.target) {
        addEdge({
          source: connection.source,
          target: connection.target,
          relation: 'dependency',
          sourcePort: connection.sourceHandle || undefined,
          targetPort: connection.targetHandle || undefined,
        });
      }
    },
    [addEdge, readOnly]
  );

  if (layoutError) {
    return (
      <div className="coral-editor coral-editor--error">
        <p>Layout Error: {layoutError}</p>
      </div>
    );
  }

  return (
    <div className="coral-editor">
      {isLayouting && (
        <div className="coral-editor__loading">
          Calculating layout...
        </div>
      )}
      <ReactFlow
        nodes={nodes}
        edges={edges}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        onNodesChange={readOnly ? undefined : onNodesChange}
        onEdgesChange={readOnly ? undefined : onEdgesChange}
        onConnect={onConnect}
        fitView
        attributionPosition="bottom-left"
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
    </div>
  );
}
```

---

## 5. Integration Mechanisms

### 5.1 The Symbiotic Loop

The core integration pattern is the **Symbiotic Loop**: changes in either interface (text or visual) propagate to the Graph-IR, which then updates the other interface.

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  User Action: Edit Text                                     │
│       │                                                     │
│       ▼                                                     │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐   │
│  │   Parser    │────▶│  Validate   │────▶│   Store     │   │
│  │ (debounced) │     │   (Zod)     │     │ (Zustand)   │   │
│  └─────────────┘     └─────────────┘     └──────┬──────┘   │
│                                                  │          │
│                                                  ▼          │
│                                          ┌─────────────┐   │
│                                          │   Layout    │   │
│                                          │   (ELK)     │   │
│                                          └──────┬──────┘   │
│                                                  │          │
│                                                  ▼          │
│                                          ┌─────────────┐   │
│                                          │  React Flow │   │
│                                          │  (render)   │   │
│                                          └─────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  User Action: Drag Node / Add Edge                          │
│       │                                                     │
│       ▼                                                     │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐   │
│  │  React Flow │────▶│   Store     │────▶│  Validate   │   │
│  │  (event)    │     │  (update)   │     │   (Zod)     │   │
│  └─────────────┘     └─────────────┘     └──────┬──────┘   │
│                                                  │          │
│                                                  ▼          │
│                                          ┌─────────────┐   │
│                                          │   Printer   │   │
│                                          │             │   │
│                                          └──────┬──────┘   │
│                                                  │          │
│                                                  ▼          │
│                                          ┌─────────────┐   │
│                                          │ Text Editor │   │
│                                          │  (update)   │   │
│                                          └─────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 Application Wiring (Playground)

The `apps/playground` is responsible for wiring the packages together:

```typescript
// apps/playground/src/App.tsx
import { useState, useCallback, useEffect } from 'react';
import { ReactFlowProvider } from '@xyflow/react';
import { parse, cstToGraph, graphToDSL } from '@coral/language';
import { Editor, useEditorStore } from '@coral/viz';
import { CoralGraphSchema, validateDAG } from '@coral/ir';
import { useDebouncedCallback } from 'use-debounce';

export function App() {
  const [dslText, setDslText] = useState(INITIAL_DSL);
  const [parseError, setParseError] = useState<string | null>(null);
  const { setGraph, graph } = useEditorStore();

  // Parse DSL and update visual editor (debounced)
  const parseAndUpdate = useDebouncedCallback(async (text: string) => {
    try {
      // 1. Parse text to CST
      const tree = await parse(text);

      // 2. Check for syntax errors
      if (tree.rootNode.hasError) {
        setParseError('Syntax error in DSL');
        return;
      }

      // 3. Transform CST to Graph-IR
      const newGraph = cstToGraph(tree.rootNode);

      // 4. Validate schema
      const schemaResult = CoralGraphSchema.safeParse(newGraph);
      if (!schemaResult.success) {
        setParseError(`Schema error: ${schemaResult.error.message}`);
        return;
      }

      // 5. Validate DAG
      const dagResult = validateDAG(newGraph);
      if (!dagResult.valid) {
        setParseError(dagResult.errors[0].message);
        return;
      }

      // 6. Update store
      setParseError(null);
      await setGraph(newGraph);
    } catch (err) {
      setParseError(err instanceof Error ? err.message : 'Parse failed');
    }
  }, 500);

  // Update DSL when graph changes from visual editor
  useEffect(() => {
    const newDsl = graphToDSL(graph);
    // Only update if meaningfully different (avoid loop)
    if (normalizeWhitespace(newDsl) !== normalizeWhitespace(dslText)) {
      setDslText(newDsl);
    }
  }, [graph]);

  // Handle text editor changes
  const handleTextChange = useCallback((newText: string) => {
    setDslText(newText);
    parseAndUpdate(newText);
  }, [parseAndUpdate]);

  return (
    <div className="app">
      <div className="app__text-panel">
        <textarea
          value={dslText}
          onChange={(e) => handleTextChange(e.target.value)}
          className="app__editor"
          spellCheck={false}
        />
        {parseError && (
          <div className="app__error">{parseError}</div>
        )}
      </div>

      <div className="app__visual-panel">
        <ReactFlowProvider>
          <Editor onChange={(g) => setGraph(g)} />
        </ReactFlowProvider>
      </div>
    </div>
  );
}

function normalizeWhitespace(text: string): string {
  return text.replace(/\s+/g, ' ').trim();
}

const INITIAL_DSL = `
service "API Gateway" {
  description: "Entry point"
}

service "Backend" {
  description: "Main service"
}

api_gateway -> backend [http_request]
`;
```

### 5.3 State Synchronization Strategy

To prevent infinite loops and ensure consistency:

1. **Single Source of Truth**: The `graph` in Zustand is canonical
2. **Debounced Parsing**: Text changes are debounced (500ms) before parsing
3. **Semantic Comparison**: Before updating text from graph, compare normalized versions
4. **Unidirectional Updates**: Each update flows one direction through the loop

```
Text Change
    │
    ▼ (debounce 500ms)
Parse → Validate → Store.setGraph()
                        │
                        ▼
                   Layout (ELK)
                        │
                        ▼
                   React Flow renders

Visual Change (drag/connect)
    │
    ▼ (immediate)
Store.updateNode() / Store.addEdge()
    │
    ▼
Validate → Print → Compare with current text
                        │
                        ▼ (only if different)
                   Update text editor
```

---

## 6. Data Flow

### 6.1 Text → Visual Flow

```
1. User types in text editor

2. Debounce timer (500ms)

3. Tree-sitter parses text
   Input:  "service \"API\" { }"
   Output: CST (Concrete Syntax Tree)

4. Bridge transforms CST to IR
   Input:  CST
   Output: { nodes: [{ id: "api", type: "service", label: "API" }], edges: [] }

5. Zod validates IR schema
   Input:  Graph-IR
   Output: Valid | Error

6. DAG validator checks for cycles
   Input:  Graph-IR
   Output: Valid | Error with cycle path

7. Store updates graph

8. ELK calculates layout (async, Web Worker)
   Input:  Graph-IR
   Output: Graph-IR + (x, y, width, height) for each node

9. React Flow renders
   Input:  Nodes with positions, Edges
   Output: Visual diagram
```

### 6.2 Visual → Text Flow

```
1. User drags node / creates edge in React Flow

2. React Flow fires onChange event

3. Store updates graph
   Example: addEdge({ source: "api", target: "db", relation: "data_flow" })

4. Zod validates updated IR

5. DAG validator checks for cycles

6. Printer generates DSL text
   Input:  Graph-IR
   Output: "service \"API\" { }\napi -> db [data_flow]"

7. Compare with current text (normalized)

8. If different, update text editor

9. ELK recalculates layout (if needed)

10. React Flow re-renders
```

### 6.3 Format Preservation Strategy

When generating text from IR, we aim to preserve user formatting. Strategy:

1. **Track Original CST**: Store the original CST alongside the IR
2. **Diff-Based Printing**: Only regenerate changed subtrees
3. **Fallback**: For new nodes, use standard formatting

```typescript
interface GraphWithContext {
  graph: CoralGraph;
  originalCST?: SyntaxNode;  // For format preservation
  nodeToCST?: Map<string, SyntaxNode>;  // Node ID → original CST node
}
```

---

## 7. Key Algorithms

### 7.1 Sugiyama Layout (ELK's Layered Algorithm)

ELK uses the Sugiyama method for hierarchical graph layout:

**Phase 1: Cycle Removal**
- Detect cycles using DFS
- Temporarily reverse back edges

**Phase 2: Layer Assignment**
- Assign nodes to horizontal layers
- Algorithm: Longest path from sources
- Complexity: O(V + E)

**Phase 3: Crossing Minimization**
- Reorder nodes within layers to minimize edge crossings
- Algorithm: Barycenter method (iterative)
- Complexity: O(V² log V) per iteration

**Phase 4: Node Placement**
- Assign x-coordinates within layers
- Respect port constraints

**Phase 5: Edge Routing**
- Route edges orthogonally
- Minimize bends

### 7.2 Cycle Detection

```typescript
function detectCycles(graph: CoralGraph): string[][] {
  const cycles: string[][] = [];
  const WHITE = 0, GRAY = 1, BLACK = 2;
  const color = new Map<string, number>();
  const parent = new Map<string, string | null>();

  const nodeIds = graph.nodes.map(n => n.id);
  const adjacency = buildAdjacency(graph);

  nodeIds.forEach(id => color.set(id, WHITE));

  function dfs(nodeId: string): void {
    color.set(nodeId, GRAY);

    for (const neighbor of adjacency.get(nodeId) || []) {
      if (color.get(neighbor) === GRAY) {
        // Found cycle - reconstruct path
        const cycle = [neighbor];
        let current = nodeId;
        while (current !== neighbor) {
          cycle.push(current);
          current = parent.get(current)!;
        }
        cycle.push(neighbor);
        cycles.push(cycle.reverse());
      } else if (color.get(neighbor) === WHITE) {
        parent.set(neighbor, nodeId);
        dfs(neighbor);
      }
    }

    color.set(nodeId, BLACK);
  }

  for (const nodeId of nodeIds) {
    if (color.get(nodeId) === WHITE) {
      parent.set(nodeId, null);
      dfs(nodeId);
    }
  }

  return cycles;
}
```

### 7.3 Incremental Parsing

Tree-sitter's incremental parsing algorithm:

```
On edit at range [start, end]:
  1. Find smallest subtree containing edit
  2. Mark subtree as "dirty"
  3. Re-parse only dirty region
  4. Splice new subtree into existing tree
  5. Propagate changes up to root

Complexity: O(edit_size + log(tree_size))
```

---

## 8. Performance Considerations

### 8.1 Benchmarks & Targets

| Operation | Target | Notes |
|-----------|--------|-------|
| Parse (incremental) | < 10ms | Per keystroke |
| Parse (full, 1000 lines) | < 100ms | Initial load |
| CST → IR transform | < 5ms | Linear in node count |
| Zod validation | < 5ms | Cached schemas |
| ELK layout (100 nodes) | < 200ms | Async in worker |
| ELK layout (500 nodes) | < 1000ms | Consider clustering |
| React Flow render | 16ms (60fps) | Viewport culling |

### 8.2 Optimization Strategies

**Debouncing**
- Text parsing: 500ms after last keystroke
- Layout recalculation: 300ms after last change

**Memoization**
- Memoize ELK layout by graph hash
- Memoize React Flow nodes by ID

**Web Workers**
- Run ELK layout in dedicated worker
- Prevents UI blocking

**Viewport Culling**
- React Flow only renders visible nodes
- Automatic; no configuration needed

**Lazy Loading**
- For large graphs, load subgraphs on demand
- Implement "drill-down" to load children

### 8.3 Scaling Limits

| Graph Size | Behavior |
|------------|----------|
| < 100 nodes | Instant feedback |
| 100-500 nodes | Slight layout delay |
| 500-1000 nodes | Noticeable layout delay; consider clustering |
| > 1000 nodes | Requires clustering / lazy loading |

---

## 9. Future Considerations

### 9.1 Collaborative Editing

For real-time collaboration:
- Use CRDTs (e.g., Yjs, Automerge) for conflict-free merging
- Operational Transformation as alternative
- Cursor presence and selection sharing

### 9.2 Code Generation from IR

Generate diagrams from code analysis:
- Parse TypeScript/Python/Go AST
- Extract module dependencies
- Generate Graph-IR automatically
- Keep diagrams in sync with code

### 9.3 Plugin System

Allow custom node types and renderers:
- Node type registry
- Custom React components
- Theme system for styling

### 9.4 Export Formats

Support additional outputs:
- SVG / PNG export
- Mermaid compatibility layer
- PlantUML export
- Markdown embedding

---

## Appendix A: Glossary

| Term | Definition |
|------|------------|
| **CST** | Concrete Syntax Tree - includes all tokens (whitespace, comments) |
| **AST** | Abstract Syntax Tree - semantic structure only |
| **IR** | Intermediate Representation - canonical data format |
| **DAG** | Directed Acyclic Graph - no cycles allowed |
| **ELK** | Eclipse Layout Kernel - graph layout library |
| **Port** | Specific attachment point on a node for edges |
| **Projectional Editing** | Dual-view editing with synchronized text/visual |
| **Symbiotic Loop** | Coral's bidirectional sync architecture |

## Appendix B: References

- [Tree-sitter Documentation](https://tree-sitter.github.io/)
- [ELK Documentation](https://www.eclipse.org/elk/)
- [React Flow Documentation](https://reactflow.dev/)
- [Zustand Documentation](https://docs.pmnd.rs/zustand/)
- [Zod Documentation](https://zod.dev/)
- [pnpm Workspaces](https://pnpm.io/workspaces)
