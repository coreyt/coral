/**
 * useExport Hook
 *
 * Handles exporting diagrams to various formats.
 * Issue #20: CCD-REQ-009 Export and Sharing
 */

import { useState, useCallback, useMemo } from 'react';
import type { GraphIR, AnnotationStore } from '../types';

// ============================================================================
// Types
// ============================================================================

export type ExportFormat = 'png' | 'svg' | 'coral-dsl' | 'json' | 'markdown';

export interface UseExportResult {
  /** Available export formats */
  availableFormats: ExportFormat[];

  /** Whether an export is in progress */
  isExporting: boolean;

  /** Last export error */
  error: string | null;

  /** Export to Coral DSL text */
  exportToCoralDSL: (graphIR: GraphIR) => Promise<string>;

  /** Export to JSON */
  exportToJSON: (graphIR: GraphIR, pretty?: boolean) => Promise<string>;

  /** Export annotations as Markdown documentation */
  exportToMarkdown: (graphIR: GraphIR, annotations: AnnotationStore) => Promise<string>;

  /** Copy text to clipboard */
  copyToClipboard: (content: string) => Promise<void>;

  /** Download content as file */
  downloadFile: (content: string, filename: string, mimeType: string) => Promise<void>;

  /** Clear error state */
  clearError: () => void;
}

// ============================================================================
// Constants
// ============================================================================

const AVAILABLE_FORMATS: ExportFormat[] = ['png', 'svg', 'coral-dsl', 'json', 'markdown'];

// ============================================================================
// Hook
// ============================================================================

export function useExport(): UseExportResult {
  const [isExporting, setIsExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // ============================================================================
  // Export to Coral DSL
  // ============================================================================

  const exportToCoralDSL = useCallback(async (graphIR: GraphIR): Promise<string> => {
    setIsExporting(true);
    setError(null);

    try {
      // Generate Coral DSL from GraphIR
      const lines: string[] = [];

      // Add header comment
      lines.push('// Generated by coral-code-design');
      lines.push('');

      // Add node declarations
      for (const node of graphIR.nodes) {
        const type = node.type || 'service';
        const label = node.label || node.id;
        lines.push(`${type} "${label}"`);
      }

      lines.push('');

      // Add edge declarations
      for (const edge of graphIR.edges) {
        const sourceNode = graphIR.nodes.find(n => n.id === edge.source);
        const targetNode = graphIR.nodes.find(n => n.id === edge.target);

        if (sourceNode && targetNode) {
          const sourceLabel = (sourceNode.label || sourceNode.id).toLowerCase().replace(/\s+/g, '_');
          const targetLabel = (targetNode.label || targetNode.id).toLowerCase().replace(/\s+/g, '_');
          const edgeType = edge.type ? ` [${edge.type}]` : '';
          lines.push(`${sourceLabel} -> ${targetLabel}${edgeType}`);
        }
      }

      return lines.join('\n');
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Export failed';
      setError(message);
      throw err;
    } finally {
      setIsExporting(false);
    }
  }, []);

  // ============================================================================
  // Export to JSON
  // ============================================================================

  const exportToJSON = useCallback(
    async (graphIR: GraphIR, pretty = true): Promise<string> => {
      setIsExporting(true);
      setError(null);

      try {
        return pretty ? JSON.stringify(graphIR, null, 2) : JSON.stringify(graphIR);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Export failed';
        setError(message);
        throw err;
      } finally {
        setIsExporting(false);
      }
    },
    []
  );

  // ============================================================================
  // Export to Markdown
  // ============================================================================

  const exportToMarkdown = useCallback(
    async (graphIR: GraphIR, annotations: AnnotationStore): Promise<string> => {
      setIsExporting(true);
      setError(null);

      try {
        const lines: string[] = [];

        // Header
        lines.push('# Diagram Documentation');
        lines.push('');
        lines.push(`Generated: ${new Date().toISOString()}`);
        lines.push('');

        // Tags section
        if (annotations.tags.length > 0) {
          lines.push('## Tags');
          lines.push('');
          for (const tag of annotations.tags) {
            lines.push(`- **${tag.name}** (${tag.id})`);
          }
          lines.push('');
        }

        // Nodes section
        lines.push('## Components');
        lines.push('');

        for (const node of graphIR.nodes) {
          const annotation = annotations.nodes[node.id];
          const label = node.label || node.id;
          const type = node.type || 'unknown';

          lines.push(`### ${label}`);
          lines.push('');
          lines.push(`- **Type**: ${type}`);

          if (annotation) {
            if (annotation.note) {
              lines.push(`- **Note**: ${annotation.note}`);
            }
            if (annotation.tags && annotation.tags.length > 0) {
              lines.push(`- **Tags**: ${annotation.tags.join(', ')}`);
            }
            if (annotation.color) {
              lines.push(`- **Color**: ${annotation.color}`);
            }
          }

          lines.push('');
        }

        // Edges section
        if (graphIR.edges.length > 0) {
          lines.push('## Relationships');
          lines.push('');

          for (const edge of graphIR.edges) {
            const sourceNode = graphIR.nodes.find(n => n.id === edge.source);
            const targetNode = graphIR.nodes.find(n => n.id === edge.target);

            if (sourceNode && targetNode) {
              const sourceLabel = sourceNode.label || sourceNode.id;
              const targetLabel = targetNode.label || targetNode.id;
              const edgeType = edge.type || 'relates to';

              lines.push(`- **${sourceLabel}** â†’ **${targetLabel}** (${edgeType})`);

              const edgeKey = `${edge.source}->${edge.target}`;
              const edgeAnnotation = annotations.edges[edgeKey];
              if (edgeAnnotation?.note) {
                lines.push(`  - ${edgeAnnotation.note}`);
              }
            }
          }

          lines.push('');
        }

        // Groups section
        if (annotations.groups.length > 0) {
          lines.push('## Groups');
          lines.push('');

          for (const group of annotations.groups) {
            lines.push(`### ${group.label}`);
            if (group.note) {
              lines.push(`${group.note}`);
            }
            lines.push('');
            lines.push('Members:');
            for (const symbolId of group.symbolIds) {
              const node = graphIR.nodes.find(n => n.id === symbolId);
              if (node) {
                lines.push(`- ${node.label || node.id}`);
              }
            }
            lines.push('');
          }
        }

        return lines.join('\n');
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Export failed';
        setError(message);
        throw err;
      } finally {
        setIsExporting(false);
      }
    },
    []
  );

  // ============================================================================
  // Copy to Clipboard
  // ============================================================================

  const copyToClipboard = useCallback(async (content: string): Promise<void> => {
    setIsExporting(true);
    setError(null);

    try {
      await navigator.clipboard.writeText(content);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Copy failed';
      setError(message);
      throw err;
    } finally {
      setIsExporting(false);
    }
  }, []);

  // ============================================================================
  // Download File
  // ============================================================================

  const downloadFile = useCallback(
    async (content: string, filename: string, mimeType: string): Promise<void> => {
      setIsExporting(true);
      setError(null);

      try {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();

        URL.revokeObjectURL(url);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Download failed';
        setError(message);
        throw err;
      } finally {
        setIsExporting(false);
      }
    },
    []
  );

  // ============================================================================
  // Clear Error
  // ============================================================================

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // ============================================================================
  // Return
  // ============================================================================

  return useMemo(
    () => ({
      availableFormats: AVAILABLE_FORMATS,
      isExporting,
      error,
      exportToCoralDSL,
      exportToJSON,
      exportToMarkdown,
      copyToClipboard,
      downloadFile,
      clearError,
    }),
    [
      isExporting,
      error,
      exportToCoralDSL,
      exportToJSON,
      exportToMarkdown,
      copyToClipboard,
      downloadFile,
      clearError,
    ]
  );
}
